// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.faceapi.implementation;

import com.azure.ai.faceapi.models.APIErrorException;
import com.azure.ai.faceapi.models.ApplySnapshotRequest;
import com.azure.ai.faceapi.models.OperationStatus;
import com.azure.ai.faceapi.models.Snapshot;
import com.azure.ai.faceapi.models.SnapshotObjectType;
import com.azure.ai.faceapi.models.SnapshotsApplyResponse;
import com.azure.ai.faceapi.models.SnapshotsTakeResponse;
import com.azure.ai.faceapi.models.TakeSnapshotRequest;
import com.azure.ai.faceapi.models.UpdateSnapshotRequest;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.serializer.CollectionFormat;
import com.azure.core.util.serializer.JacksonAdapter;
import java.util.List;
import java.util.UUID;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in Snapshots. */
public final class SnapshotsImpl {
    /** The proxy service used to perform REST calls. */
    private final SnapshotsService service;

    /** The service client containing this operation class. */
    private final FaceClientImpl client;

    /**
     * Initializes an instance of SnapshotsImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    SnapshotsImpl(FaceClientImpl client) {
        this.service = RestProxy.create(SnapshotsService.class, client.getHttpPipeline());
        this.client = client;
    }

    /**
     * The interface defining all the services for FaceClientSnapshots to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{Endpoint}/face/v1.0")
    @ServiceInterface(name = "FaceClientSnapshots")
    private interface SnapshotsService {
        @Post("/snapshots")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SnapshotsTakeResponse> take(
                @HostParam("Endpoint") String endpoint, @BodyParam("application/json") TakeSnapshotRequest body);

        @Get("/snapshots")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<Response<List<Snapshot>>> list(
                @HostParam("Endpoint") String endpoint,
                @QueryParam("type") SnapshotObjectType type,
                @QueryParam("applyScope") String applyScope);

        @Get("/snapshots/{snapshotId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<Response<Snapshot>> get(@HostParam("Endpoint") String endpoint, @PathParam("snapshotId") UUID snapshotId);

        @Patch("/snapshots/{snapshotId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<Response<Void>> update(
                @HostParam("Endpoint") String endpoint,
                @PathParam("snapshotId") UUID snapshotId,
                @BodyParam("application/json") UpdateSnapshotRequest body);

        @Delete("/snapshots/{snapshotId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<Response<Void>> delete(@HostParam("Endpoint") String endpoint, @PathParam("snapshotId") UUID snapshotId);

        @Post("/snapshots/{snapshotId}/apply")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SnapshotsApplyResponse> apply(
                @HostParam("Endpoint") String endpoint,
                @PathParam("snapshotId") UUID snapshotId,
                @BodyParam("application/json") ApplySnapshotRequest body);

        @Get("/operations/{operationId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<Response<OperationStatus>> getOperationStatus(
                @HostParam("Endpoint") String endpoint, @PathParam("operationId") UUID operationId);
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with
     * user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt; The snapshot
     * interfaces are for users to backup and restore their face data from one face subscription to another, inside same
     * region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of
     * the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target
     * subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be
     * applied cross accounts and regions.&lt;br /&gt; Taking snapshot is an asynchronous operation. An operation id can
     * be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for
     * tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field
     * in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt; Snapshot taking time
     * depends on the number of person and face entries in the source object. It could be in seconds, or up to several
     * hours for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned
     * in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by
     * themselves any time before expiration.&lt;br /&gt; Taking snapshot for a certain object will not block any other
     * operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be
     * conducted as usual. For all writable operations, including Add/Update/Delete the source object or its
     * persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected
     * on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can
     * work as normal. Snapshot will also include the training results of the source object, which means target
     * subscription the snapshot applied to does not need re-train the target object before calling
     * Identify/FindSimilar.&lt;br /&gt; * Free-tier subscription quota: 100 take operations per month. * S0-tier
     * subscription quota: 100 take operations per day.
     *
     * @param type Type of the source object in the snapshot, specified by the subscriber who created the snapshot when
     *     calling Snapshot - Take. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created
     *     the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope
     *     of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SnapshotsTakeResponse> takeWithResponseAsync(
            SnapshotObjectType type, String objectId, List<UUID> applyScope, String userData) {
        TakeSnapshotRequest body = new TakeSnapshotRequest();
        body.setType(type);
        body.setObjectId(objectId);
        body.setApplyScope(applyScope);
        body.setUserData(userData);
        return service.take(this.client.getEndpoint(), body);
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with
     * user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt; The snapshot
     * interfaces are for users to backup and restore their face data from one face subscription to another, inside same
     * region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of
     * the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target
     * subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be
     * applied cross accounts and regions.&lt;br /&gt; Taking snapshot is an asynchronous operation. An operation id can
     * be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for
     * tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field
     * in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt; Snapshot taking time
     * depends on the number of person and face entries in the source object. It could be in seconds, or up to several
     * hours for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned
     * in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by
     * themselves any time before expiration.&lt;br /&gt; Taking snapshot for a certain object will not block any other
     * operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be
     * conducted as usual. For all writable operations, including Add/Update/Delete the source object or its
     * persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected
     * on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can
     * work as normal. Snapshot will also include the training results of the source object, which means target
     * subscription the snapshot applied to does not need re-train the target object before calling
     * Identify/FindSimilar.&lt;br /&gt; * Free-tier subscription quota: 100 take operations per month. * S0-tier
     * subscription quota: 100 take operations per day.
     *
     * @param type Type of the source object in the snapshot, specified by the subscriber who created the snapshot when
     *     calling Snapshot - Take. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created
     *     the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope
     *     of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> takeAsync(SnapshotObjectType type, String objectId, List<UUID> applyScope, String userData) {
        return takeWithResponseAsync(type, objectId, applyScope, userData)
                .flatMap((SnapshotsTakeResponse res) -> Mono.empty());
    }

    /**
     * Submit an operation to take a snapshot of face list, large face list, person group or large person group, with
     * user-specified snapshot type, source object id, apply scope and an optional user data.&lt;br /&gt; The snapshot
     * interfaces are for users to backup and restore their face data from one face subscription to another, inside same
     * region or across regions. The workflow contains two phases, user first calls Snapshot - Take to create a copy of
     * the source object and store it as a snapshot, then calls Snapshot - Apply to paste the snapshot to target
     * subscription. The snapshots are stored in a centralized location (per Azure instance), so that they can be
     * applied cross accounts and regions.&lt;br /&gt; Taking snapshot is an asynchronous operation. An operation id can
     * be obtained from the "Operation-Location" field in response header, to be used in OperationStatus - Get for
     * tracking the progress of creating the snapshot. The snapshot id will be included in the "resourceLocation" field
     * in OperationStatus - Get response when the operation status is "succeeded".&lt;br /&gt; Snapshot taking time
     * depends on the number of person and face entries in the source object. It could be in seconds, or up to several
     * hours for 1,000,000 persons with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned
     * in 48 hours after it is created by Snapshot - Take. User can delete the snapshot using Snapshot - Delete by
     * themselves any time before expiration.&lt;br /&gt; Taking snapshot for a certain object will not block any other
     * operations against the object. All read-only operations (Get/List and Identify/FindSimilar/Verify) can be
     * conducted as usual. For all writable operations, including Add/Update/Delete the source object or its
     * persons/faces and Train, they are not blocked but not recommended because writable updates may not be reflected
     * on the snapshot during its taking. After snapshot taking is completed, all readable and writable operations can
     * work as normal. Snapshot will also include the training results of the source object, which means target
     * subscription the snapshot applied to does not need re-train the target object before calling
     * Identify/FindSimilar.&lt;br /&gt; * Free-tier subscription quota: 100 take operations per month. * S0-tier
     * subscription quota: 100 take operations per day.
     *
     * @param type Type of the source object in the snapshot, specified by the subscriber who created the snapshot when
     *     calling Snapshot - Take. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
     * @param objectId User specified source object id to take snapshot from.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created
     *     the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope
     *     of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void take(SnapshotObjectType type, String objectId, List<UUID> applyScope, String userData) {
        takeAsync(type, objectId, applyScope, userData).block();
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or
     * snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param type Type of the source object in the snapshot, specified by the subscriber who created the snapshot when
     *     calling Snapshot - Take. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
     * @param applyScope Array of ApplyScopeItemsItem.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an array of snapshots.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<List<Snapshot>>> listWithResponseAsync(SnapshotObjectType type, List<UUID> applyScope) {
        String applyScopeConverted =
                JacksonAdapter.createDefaultSerializerAdapter().serializeList(applyScope, CollectionFormat.CSV);
        return service.list(this.client.getEndpoint(), type, applyScopeConverted);
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or
     * snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param type Type of the source object in the snapshot, specified by the subscriber who created the snapshot when
     *     calling Snapshot - Take. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
     * @param applyScope Array of ApplyScopeItemsItem.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an array of snapshots.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<Snapshot>> listAsync(SnapshotObjectType type, List<UUID> applyScope) {
        return listWithResponseAsync(type, applyScope)
                .flatMap(
                        (Response<List<Snapshot>> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * List all accessible snapshots with related information, including snapshots that were taken by the user, or
     * snapshots to be applied to the user (subscription id was included in the applyScope in Snapshot - Take).
     *
     * @param type Type of the source object in the snapshot, specified by the subscriber who created the snapshot when
     *     calling Snapshot - Take. Currently FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
     * @param applyScope Array of ApplyScopeItemsItem.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return an array of snapshots.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public List<Snapshot> list(SnapshotObjectType type, List<UUID> applyScope) {
        return listAsync(type, applyScope).block();
    }

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and
     * target subscriptions included in the applyScope in Snapshot - Take.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return snapshot object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Snapshot>> getWithResponseAsync(UUID snapshotId) {
        return service.get(this.client.getEndpoint(), snapshotId);
    }

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and
     * target subscriptions included in the applyScope in Snapshot - Take.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return snapshot object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Snapshot> getAsync(UUID snapshotId) {
        return getWithResponseAsync(snapshotId)
                .flatMap(
                        (Response<Snapshot> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Retrieve information about a snapshot. Snapshot is only accessible to the source subscription who took it, and
     * target subscriptions included in the applyScope in Snapshot - Take.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return snapshot object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Snapshot get(UUID snapshotId) {
        return getAsync(snapshotId).block();
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created
     *     the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope
     *     of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> updateWithResponseAsync(UUID snapshotId, List<UUID> applyScope, String userData) {
        UpdateSnapshotRequest body = new UpdateSnapshotRequest();
        body.setApplyScope(applyScope);
        body.setUserData(userData);
        return service.update(this.client.getEndpoint(), snapshotId, body);
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created
     *     the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope
     *     of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAsync(UUID snapshotId, List<UUID> applyScope, String userData) {
        return updateWithResponseAsync(snapshotId, applyScope, userData).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Update the information of a snapshot. Only the source subscription who took the snapshot can update the snapshot.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param applyScope Array of the target Face subscription ids for the snapshot, specified by the user who created
     *     the snapshot when calling Snapshot - Take. For each snapshot, only subscriptions included in the applyScope
     *     of Snapshot - Take can apply it.
     * @param userData User specified data about the snapshot for any purpose. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void update(UUID snapshotId, List<UUID> applyScope, String userData) {
        updateAsync(snapshotId, applyScope, userData).block();
    }

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will
     * also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not
     * delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> deleteWithResponseAsync(UUID snapshotId) {
        return service.delete(this.client.getEndpoint(), snapshotId);
    }

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will
     * also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not
     * delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAsync(UUID snapshotId) {
        return deleteWithResponseAsync(snapshotId).flatMap((Response<Void> res) -> Mono.empty());
    }

    /**
     * Delete an existing snapshot according to the snapshotId. All object data and information in the snapshot will
     * also be deleted. Only the source subscription who took the snapshot can delete the snapshot. If the user does not
     * delete a snapshot with this API, the snapshot will still be automatically deleted in 48 hours after creation.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void delete(UUID snapshotId) {
        deleteAsync(snapshotId).block();
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included
     * in the applyScope of Snapshot - Take can apply it.&lt;br /&gt; The snapshot interfaces are for users to backup
     * and restore their face data from one face subscription to another, inside same region or across regions. The
     * workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it
     * as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored
     * in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br
     * /&gt; Applying snapshot is an asynchronous operation. An operation id can be obtained from the
     * "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of
     * applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus -
     * Get response when the operation status is "succeeded".&lt;br /&gt; Snapshot applying time depends on the number
     * of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons
     * with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is
     * created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its
     * creation.&lt;br /&gt; Applying a snapshot will not block any other operations against the target object, however
     * it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot
     * applying is completed, all operations towards the target object can work as normal. Snapshot also includes the
     * training results of the source object, which means target subscription the snapshot applied to does not need
     * re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; One snapshot can be applied multiple
     * times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will
     * fail if target subscription already contains an object of same type and using the same objectId. Users can
     * specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt; * Free-tier subscription quota: 100
     * apply operations per month. * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SnapshotsApplyResponse> applyWithResponseAsync(UUID snapshotId, String objectId) {
        ApplySnapshotRequest body = new ApplySnapshotRequest();
        body.setObjectId(objectId);
        return service.apply(this.client.getEndpoint(), snapshotId, body);
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included
     * in the applyScope of Snapshot - Take can apply it.&lt;br /&gt; The snapshot interfaces are for users to backup
     * and restore their face data from one face subscription to another, inside same region or across regions. The
     * workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it
     * as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored
     * in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br
     * /&gt; Applying snapshot is an asynchronous operation. An operation id can be obtained from the
     * "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of
     * applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus -
     * Get response when the operation status is "succeeded".&lt;br /&gt; Snapshot applying time depends on the number
     * of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons
     * with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is
     * created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its
     * creation.&lt;br /&gt; Applying a snapshot will not block any other operations against the target object, however
     * it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot
     * applying is completed, all operations towards the target object can work as normal. Snapshot also includes the
     * training results of the source object, which means target subscription the snapshot applied to does not need
     * re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; One snapshot can be applied multiple
     * times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will
     * fail if target subscription already contains an object of same type and using the same objectId. Users can
     * specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt; * Free-tier subscription quota: 100
     * apply operations per month. * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the completion.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> applyAsync(UUID snapshotId, String objectId) {
        return applyWithResponseAsync(snapshotId, objectId).flatMap((SnapshotsApplyResponse res) -> Mono.empty());
    }

    /**
     * Submit an operation to apply a snapshot to current subscription. For each snapshot, only subscriptions included
     * in the applyScope of Snapshot - Take can apply it.&lt;br /&gt; The snapshot interfaces are for users to backup
     * and restore their face data from one face subscription to another, inside same region or across regions. The
     * workflow contains two phases, user first calls Snapshot - Take to create a copy of the source object and store it
     * as a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The snapshots are stored
     * in a centralized location (per Azure instance), so that they can be applied cross accounts and regions.&lt;br
     * /&gt; Applying snapshot is an asynchronous operation. An operation id can be obtained from the
     * "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking the progress of
     * applying the snapshot. The target object id will be included in the "resourceLocation" field in OperationStatus -
     * Get response when the operation status is "succeeded".&lt;br /&gt; Snapshot applying time depends on the number
     * of person and face entries in the snapshot object. It could be in seconds, or up to 1 hour for 1,000,000 persons
     * with multiple faces.&lt;br /&gt; Snapshots will be automatically expired and cleaned in 48 hours after it is
     * created by Snapshot - Take. So the target subscription is required to apply the snapshot in 48 hours since its
     * creation.&lt;br /&gt; Applying a snapshot will not block any other operations against the target object, however
     * it is not recommended because the correctness cannot be guaranteed during snapshot applying. After snapshot
     * applying is completed, all operations towards the target object can work as normal. Snapshot also includes the
     * training results of the source object, which means target subscription the snapshot applied to does not need
     * re-train the target object before calling Identify/FindSimilar.&lt;br /&gt; One snapshot can be applied multiple
     * times in parallel, while currently only CreateNew apply mode is supported, which means the apply operation will
     * fail if target subscription already contains an object of same type and using the same objectId. Users can
     * specify the "objectId" in request body to avoid such conflicts.&lt;br /&gt; * Free-tier subscription quota: 100
     * apply operations per month. * S0-tier subscription quota: 100 apply operations per day.
     *
     * @param snapshotId Id referencing a particular snapshot.
     * @param objectId User specified target object id to be created from the snapshot.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void apply(UUID snapshotId, String objectId) {
        applyAsync(snapshotId, objectId).block();
    }

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param operationId Id referencing a particular take/apply snapshot operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<OperationStatus>> getOperationStatusWithResponseAsync(UUID operationId) {
        return service.getOperationStatus(this.client.getEndpoint(), operationId);
    }

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param operationId Id referencing a particular take/apply snapshot operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<OperationStatus> getOperationStatusAsync(UUID operationId) {
        return getOperationStatusWithResponseAsync(operationId)
                .flatMap(
                        (Response<OperationStatus> res) -> {
                            if (res.getValue() != null) {
                                return Mono.just(res.getValue());
                            } else {
                                return Mono.empty();
                            }
                        });
    }

    /**
     * Retrieve the status of a take/apply snapshot operation.
     *
     * @param operationId Id referencing a particular take/apply snapshot operation.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws APIErrorException thrown if the request is rejected by server.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return operation status object.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public OperationStatus getOperationStatus(UUID operationId) {
        return getOperationStatusAsync(operationId).block();
    }
}
