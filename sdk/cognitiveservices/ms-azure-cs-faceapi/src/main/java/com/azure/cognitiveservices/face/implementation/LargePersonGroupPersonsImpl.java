// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.cognitiveservices.face.implementation;

import com.azure.cognitiveservices.face.LargePersonGroupPersons;
import com.azure.cognitiveservices.face.models.APIErrorException;
import com.azure.cognitiveservices.face.models.DetectionModel;
import com.azure.cognitiveservices.face.models.ImageUrl;
import com.azure.cognitiveservices.face.models.NameAndUserDataContract;
import com.azure.cognitiveservices.face.models.PersistedFace;
import com.azure.cognitiveservices.face.models.Person;
import com.azure.cognitiveservices.face.models.UpdateFaceRequest;
import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.Patch;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.http.rest.SimpleResponse;
import com.azure.core.http.rest.VoidResponse;
import com.azure.core.implementation.CollectionFormat;
import com.azure.core.implementation.RestProxy;
import com.azure.core.implementation.serializer.jackson.JacksonAdapter;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.UUID;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in
 * LargePersonGroupPersons.
 */
public final class LargePersonGroupPersonsImpl implements LargePersonGroupPersons {
    /**
     * The proxy service used to perform REST calls.
     */
    private LargePersonGroupPersonsService service;

    /**
     * The service client containing this operation class.
     */
    private FaceClientImpl client;

    /**
     * Initializes an instance of LargePersonGroupPersonsImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    public LargePersonGroupPersonsImpl(FaceClientImpl client) {
        this.service = RestProxy.create(LargePersonGroupPersonsService.class, client.getHttpPipeline());
        this.client = client;
    }

    /**
     * The interface defining all the services for
     * FaceClientLargePersonGroupPersons to be used by the proxy service to
     * perform REST calls.
     */
    @Host("{Endpoint}/face/v1.0")
    @ServiceInterface(name = "FaceClientLargePersonGroupPersons")
    private interface LargePersonGroupPersonsService {
        @Post("largepersongroups/{largePersonGroupId}/persons")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SimpleResponse<Person>> create(@PathParam("largePersonGroupId") String largePersonGroupId, @HostParam("Endpoint") String endpoint, @BodyParam("application/json; charset=utf-8") NameAndUserDataContract body);

        @Get("largepersongroups/{largePersonGroupId}/persons")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SimpleResponse<List<Person>>> list(@PathParam("largePersonGroupId") String largePersonGroupId, @HostParam("Endpoint") String endpoint, @QueryParam("start") String start, @QueryParam("top") Integer top);

        @Delete("largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<VoidResponse> delete(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @HostParam("Endpoint") String endpoint);

        @Get("largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SimpleResponse<Person>> get(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @HostParam("Endpoint") String endpoint);

        @Patch("largepersongroups/{largePersonGroupId}/persons/{personId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<VoidResponse> update(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @HostParam("Endpoint") String endpoint, @BodyParam("application/json; charset=utf-8") NameAndUserDataContract body);

        @Delete("largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<VoidResponse> deleteFace(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @PathParam("persistedFaceId") UUID persistedFaceId, @HostParam("Endpoint") String endpoint);

        @Get("largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SimpleResponse<PersistedFace>> getFace(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @PathParam("persistedFaceId") UUID persistedFaceId, @HostParam("Endpoint") String endpoint);

        @Patch("largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<VoidResponse> updateFace(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @PathParam("persistedFaceId") UUID persistedFaceId, @HostParam("Endpoint") String endpoint, @BodyParam("application/json; charset=utf-8") UpdateFaceRequest body);

        @Post("largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SimpleResponse<PersistedFace>> addFaceFromUrl(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @HostParam("Endpoint") String endpoint, @QueryParam("userData") String userData, @QueryParam("targetFace") String targetFace, @QueryParam("detectionModel") DetectionModel detectionModel1, @BodyParam("application/json; charset=utf-8") ImageUrl imageUrl);

        @Post("largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(APIErrorException.class)
        Mono<SimpleResponse<PersistedFace>> addFaceFromStream(@PathParam("largePersonGroupId") String largePersonGroupId, @PathParam("personId") UUID personId, @HostParam("Endpoint") String endpoint, @QueryParam("userData") String userData, @QueryParam("targetFace") String targetFace, @HeaderParam("Content-Length") long contentLength, @BodyParam("application/octet-stream") Flux<ByteBuffer> image, @QueryParam("detectionModel") DetectionModel detectionModel1);
    }

    /**
     * Create a new person in a specified large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Person>> createWithRestResponseAsync(String largePersonGroupId) {
        NameAndUserDataContract body = new NameAndUserDataContract();
        body.setName(null);
        body.setUserData(null);
        return service.create(largePersonGroupId, this.client.getEndpoint(), body);
    }

    /**
     * Create a new person in a specified large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Person> createAsync(String largePersonGroupId) {
        return createWithRestResponseAsync(largePersonGroupId)
            .flatMap((SimpleResponse<Person> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Create a new person in a specified large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Person>> createWithRestResponseAsync(String largePersonGroupId, String name, String userData) {
        NameAndUserDataContract body = new NameAndUserDataContract();
        body.setName(name);
        body.setUserData(userData);
        return service.create(largePersonGroupId, this.client.getEndpoint(), body);
    }

    /**
     * Create a new person in a specified large person group.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Person> createAsync(String largePersonGroupId, String name, String userData) {
        return createWithRestResponseAsync(largePersonGroupId, name, userData)
            .flatMap((SimpleResponse<Person> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<List<Person>>> listWithRestResponseAsync(String largePersonGroupId) {
        final String start = null;
        final Integer top = null;
        return service.list(largePersonGroupId, this.client.getEndpoint(), start, top);
    }

    /**
     * List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<Person>> listAsync(String largePersonGroupId) {
        return listWithRestResponseAsync(largePersonGroupId)
            .flatMap((SimpleResponse<List<Person>> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param start Starting person id to return (used to list a range of persons).
     * @param top Number of persons to return starting with the person id indicated by the 'start' parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<List<Person>>> listWithRestResponseAsync(String largePersonGroupId, String start, Integer top) {
        return service.list(largePersonGroupId, this.client.getEndpoint(), start, top);
    }

    /**
     * List all persons in a large person group, and retrieve person information (including personId, name, userData and persistedFaceIds of registered faces of the person).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param start Starting person id to return (used to list a range of persons).
     * @param top Number of persons to return starting with the person id indicated by the 'start' parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<List<Person>> listAsync(String largePersonGroupId, String start, Integer top) {
        return listWithRestResponseAsync(largePersonGroupId, start, top)
            .flatMap((SimpleResponse<List<Person>> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VoidResponse> deleteWithRestResponseAsync(String largePersonGroupId, UUID personId) {
        return service.delete(largePersonGroupId, personId, this.client.getEndpoint());
    }

    /**
     * Delete an existing person from a large person group. The persistedFaceId, userData, person name and face feature in the person entry will all be deleted.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteAsync(String largePersonGroupId, UUID personId) {
        return deleteWithRestResponseAsync(largePersonGroupId, personId)
            .flatMap((VoidResponse res) -> Mono.empty());
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<Person>> getWithRestResponseAsync(String largePersonGroupId, UUID personId) {
        return service.get(largePersonGroupId, personId, this.client.getEndpoint());
    }

    /**
     * Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Person> getAsync(String largePersonGroupId, UUID personId) {
        return getWithRestResponseAsync(largePersonGroupId, personId)
            .flatMap((SimpleResponse<Person> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Update name or userData of a person.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VoidResponse> updateWithRestResponseAsync(String largePersonGroupId, UUID personId) {
        NameAndUserDataContract body = new NameAndUserDataContract();
        body.setName(null);
        body.setUserData(null);
        return service.update(largePersonGroupId, personId, this.client.getEndpoint(), body);
    }

    /**
     * Update name or userData of a person.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAsync(String largePersonGroupId, UUID personId) {
        return updateWithRestResponseAsync(largePersonGroupId, personId)
            .flatMap((VoidResponse res) -> Mono.empty());
    }

    /**
     * Update name or userData of a person.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VoidResponse> updateWithRestResponseAsync(String largePersonGroupId, UUID personId, String name, String userData) {
        NameAndUserDataContract body = new NameAndUserDataContract();
        body.setName(name);
        body.setUserData(userData);
        return service.update(largePersonGroupId, personId, this.client.getEndpoint(), body);
    }

    /**
     * Update name or userData of a person.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param name User defined name, maximum length is 128.
     * @param userData User specified data. Length should not exceed 16KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateAsync(String largePersonGroupId, UUID personId, String name, String userData) {
        return updateWithRestResponseAsync(largePersonGroupId, personId, name, userData)
            .flatMap((VoidResponse res) -> Mono.empty());
    }

    /**
     * Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId.
     * &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VoidResponse> deleteFaceWithRestResponseAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId) {
        return service.deleteFace(largePersonGroupId, personId, persistedFaceId, this.client.getEndpoint());
    }

    /**
     * Delete a face from a person in a large person group by specified largePersonGroupId, personId and persistedFaceId.
     * &lt;br /&gt; Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> deleteFaceAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId) {
        return deleteFaceWithRestResponseAsync(largePersonGroupId, personId, persistedFaceId)
            .flatMap((VoidResponse res) -> Mono.empty());
    }

    /**
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging largePersonGroupId).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<PersistedFace>> getFaceWithRestResponseAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId) {
        return service.getFace(largePersonGroupId, personId, persistedFaceId, this.client.getEndpoint());
    }

    /**
     * Retrieve information about a persisted face (specified by persistedFaceId, personId and its belonging largePersonGroupId).
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersistedFace> getFaceAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId) {
        return getFaceWithRestResponseAsync(largePersonGroupId, personId, persistedFaceId)
            .flatMap((SimpleResponse<PersistedFace> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VoidResponse> updateFaceWithRestResponseAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId) {
        UpdateFaceRequest body = new UpdateFaceRequest();
        body.setUserData(null);
        return service.updateFace(largePersonGroupId, personId, persistedFaceId, this.client.getEndpoint(), body);
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateFaceAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId) {
        return updateFaceWithRestResponseAsync(largePersonGroupId, personId, persistedFaceId)
            .flatMap((VoidResponse res) -> Mono.empty());
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @param userData User-provided data attached to the face. The size limit is 1KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<VoidResponse> updateFaceWithRestResponseAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId, String userData) {
        UpdateFaceRequest body = new UpdateFaceRequest();
        body.setUserData(userData);
        return service.updateFace(largePersonGroupId, personId, persistedFaceId, this.client.getEndpoint(), body);
    }

    /**
     * Update a person persisted face's userData field.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param persistedFaceId Id referencing a particular persistedFaceId of an existing face.
     * @param userData User-provided data attached to the face. The size limit is 1KB.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Void> updateFaceAsync(String largePersonGroupId, UUID personId, UUID persistedFaceId, String userData) {
        return updateFaceWithRestResponseAsync(largePersonGroupId, personId, persistedFaceId, userData)
            .flatMap((VoidResponse res) -> Mono.empty());
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param url Publicly reachable URL of an image.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<PersistedFace>> addFaceFromUrlWithRestResponseAsync(String largePersonGroupId, UUID personId, String url) {
        final String userData = null;
        final DetectionModel detectionModel = DetectionModel.DETECTION_01;
        ImageUrl imageUrl = new ImageUrl();
        imageUrl.setUrl(url);
        String targetFaceConverted = null;
        return service.addFaceFromUrl(largePersonGroupId, personId, this.client.getEndpoint(), userData, targetFaceConverted, detectionModel, imageUrl);
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param url Publicly reachable URL of an image.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersistedFace> addFaceFromUrlAsync(String largePersonGroupId, UUID personId, String url) {
        return addFaceFromUrlWithRestResponseAsync(largePersonGroupId, personId, url)
            .flatMap((SimpleResponse<PersistedFace> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param url Publicly reachable URL of an image.
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB.
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it. Possible values include: 'detection_01', 'detection_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<PersistedFace>> addFaceFromUrlWithRestResponseAsync(String largePersonGroupId, UUID personId, String url, String userData, List<Integer> targetFace, DetectionModel detectionModel) {
        ImageUrl imageUrl = new ImageUrl();
        imageUrl.setUrl(url);
        String targetFaceConverted = JacksonAdapter.createDefaultSerializerAdapter().serializeList(targetFace, CollectionFormat.CSV);
        return service.addFaceFromUrl(largePersonGroupId, personId, this.client.getEndpoint(), userData, targetFaceConverted, detectionModel, imageUrl);
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param url Publicly reachable URL of an image.
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB.
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it. Possible values include: 'detection_01', 'detection_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersistedFace> addFaceFromUrlAsync(String largePersonGroupId, UUID personId, String url, String userData, List<Integer> targetFace, DetectionModel detectionModel) {
        return addFaceFromUrlWithRestResponseAsync(largePersonGroupId, personId, url, userData, targetFace, detectionModel)
            .flatMap((SimpleResponse<PersistedFace> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param contentLength The content length.
     * @param image An image stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<PersistedFace>> addFaceFromStreamWithRestResponseAsync(String largePersonGroupId, UUID personId, long contentLength, Flux<ByteBuffer> image) {
        final String userData = null;
        final DetectionModel detectionModel = DetectionModel.DETECTION_01;
        String targetFaceConverted = null;
        return service.addFaceFromStream(largePersonGroupId, personId, this.client.getEndpoint(), userData, targetFaceConverted, contentLength, image, detectionModel);
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param contentLength The content length.
     * @param image An image stream.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersistedFace> addFaceFromStreamAsync(String largePersonGroupId, UUID personId, long contentLength, Flux<ByteBuffer> image) {
        return addFaceFromStreamWithRestResponseAsync(largePersonGroupId, personId, contentLength, image)
            .flatMap((SimpleResponse<PersistedFace> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param contentLength The content length.
     * @param image An image stream.
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB.
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it. Possible values include: 'detection_01', 'detection_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SimpleResponse<PersistedFace>> addFaceFromStreamWithRestResponseAsync(String largePersonGroupId, UUID personId, long contentLength, Flux<ByteBuffer> image, String userData, List<Integer> targetFace, DetectionModel detectionModel) {
        String targetFaceConverted = JacksonAdapter.createDefaultSerializerAdapter().serializeList(targetFace, CollectionFormat.CSV);
        return service.addFaceFromStream(largePersonGroupId, personId, this.client.getEndpoint(), userData, targetFaceConverted, contentLength, image, detectionModel);
    }

    /**
     * Add a face to a person into a large person group for face identification or verification. To deal with an image contains multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature will be stored on server until [LargePersonGroup PersonFace - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ae2966ac60f11b48b5aa3), [LargePersonGroup Person - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599ade5c6ac60f11b48b5aa2) or [LargePersonGroup - Delete](/docs/services/563879b61984550e40cbbe8d/operations/599adc216ac60f11b48b5a9f) is called.
     * &lt;br /&gt; Note persistedFaceId is different from faceId generated by [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236).
     * * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
     * * Each person entry can hold up to 248 faces.
     * * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
     * * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from [Face - Detect](/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236), there’s no guarantee to detect and add the face successfully.
     * * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
     * * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
     * * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
     * * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to [How to specify a detection model](https://docs.microsoft.com/en-us/azure/cognitive-services/face/face-api-how-to-topics/specify-detection-model)
     *   | Model | Recommended use-case(s) |
     *   | ---------- | -------- |
     *   | 'detection_01': | The default detection model for [LargePersonGroup Person - Add Face](/docs/services/563879b61984550e40cbbe8d/operations/599adf2a3a7b9412a4d53f42). Recommend for near frontal face detection. For scenarios with exceptionally large angle (head-pose) faces, occluded faces or wrong image orientation, the faces in such cases may not be detected. |
     *   | 'detection_02': | Detection model released in 2019 May with improved accuracy especially on small, side and blurry faces. |.
     *
     * @param largePersonGroupId Id referencing a particular large person group.
     * @param personId Id referencing a particular person.
     * @param contentLength The content length.
     * @param image An image stream.
     * @param userData User-specified data about the face for any purpose. The maximum length is 1KB.
     * @param targetFace A face rectangle to specify the target face to be added to a person in the format of "targetFace=left,top,width,height". E.g. "targetFace=10,10,100,100". If there is more than one face in the image, targetFace is required to specify which face to add. No targetFace means there is only one face detected in the entire image.
     * @param detectionModel Name of detection model. Detection model is used to detect faces in the submitted image. A detection model name can be provided when performing Face - Detect or (Large)FaceList - Add Face or (Large)PersonGroup - Add Face. The default value is 'detection_01', if another model is needed, please explicitly specify it. Possible values include: 'detection_01', 'detection_02'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @return a Mono which performs the network request upon subscription.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PersistedFace> addFaceFromStreamAsync(String largePersonGroupId, UUID personId, long contentLength, Flux<ByteBuffer> image, String userData, List<Integer> targetFace, DetectionModel detectionModel) {
        return addFaceFromStreamWithRestResponseAsync(largePersonGroupId, personId, contentLength, image, userData, targetFace, detectionModel)
            .flatMap((SimpleResponse<PersistedFace> res) -> {
                if (res.getValue() != null) {
                    return Mono.just(res.getValue());
                } else {
                    return Mono.empty();
                }
            });
    }
}
